# Introduction

- ### A device driver is a piece of code that configures and manages a device.
- ### A device driver knows how to configure the device and knows how to send the data and also knows how to process the requests which originate from the device.
- ### When the device driver code is loaded into the operation system such as Linux, it exposes interfaces to the user-space so that the user application can communicate with the device.
- ### The device driver code also abstracts various hardware details from the user-space applications.
- ### The user applications can just use the traditional system calls such as open, write, read to talk to the device. But those system calls are carefully handled by the driver code to touch various registers of the device.
- ### The kernels job here is to connect the system calls to the drivers system called implementation methods.

![](./Pics/3.device_driver_01.png)


- ### Let's say, there is a device xyz and when you load a driver of that device, then that device driver exposes the interfaces to the user-space. So that the user-space applications can communicate with the device. The kernel or the operating system doesn't know how to handle a device. Because, a device has various configuration registers, it has various configuration values which needs to be program to the hardware. Also the kernel doesn't know how to handle the interrupts generated by the hardware. That's a reason why you should load a device driver. 

- ### A driver should give an interface to the user space level programs to communicate with a hardware. In Linux, we access the device by using a file access technique. For example, let's consider this is a RTC device. What you do with a RTC device? So, you read data and time information from the RTC or you write into the RTC if you want to configure it. Basically, we do read-write operations on a device. That's why, the device driver has to create a device file interface at the user's space, so that user level programs can communicate with the hardware, using a traditional file access system calls such as open, close, read, write, etc..

> ### So, here the job of the kernel is to connect system call execution from the user-space to the driver's system call handler methods. That will be taken care by the kernel.

- ### There are various categories of Linux device drivers. There are character drivers which take care of character devices, there are block drivers which take care of block devices such as storage devices, and there are network device drivers which take care of network devices.

![](./Pics/3.device_driver_02.png)

- ### Character driver accesses data from the device sequentially.i.e., byte by byte (like a stream of characters) not as a chunk of data. Sophisticated buffering strategies are usually not involved in char drivers. Because when you write 1 byte, it directly goes to the device without any intermediate buffering, or delayed write back, or there is no a dirty buffer management as in block drivers. Some of the examples of char devices are sensors, RTC, keyboard, serial port, parallel port, all these are character devices and you need character drivers to manage these devices.

![](./Pics/3.device_driver_03.png)

- ### For example, when you use write system call to write 1 byte of data, it directly goes to the hardware via the driver. The drivers knows how to forward that data to the RTC device.  But this is not the case in a block drivers. For example, let's say you have a memory device such as SDMMC card. So, the SDMMC specification or the design doesn't allow you to a write data byte by byte. You either have to write in chunks such as a 512 bytes, or 1024 bytes. What are block drivers? The device which handles data in chunks or blocks is called a block device.Block drivers are more complicated than char drivers because the block drivers should implement advanced buffering strategies to read and write to the block drivers, and the disk caches are also involved. Examples are mass storage devices such as hard disks, SDMMC, Nand flash, USB camera, etc..

- ### The driver has to create some a interfaces at the user-space. So, that the user level programs can use that interface to communicate with the hardware. Those are called as ```device files```. Most of the devices are accessed as a file in Unix/Linux system. A device file is a special file or a node which gets populated in ```/dev``` directory during kernel boot time or ```device/driver``` hot plug events. When you boot your Linux kernel, the ```/dev``` directory is automatically it will get populated with device files, which are a generated from various drivers of the kernel.

> ### Device file is a special file and by using device file user application and drivers communicate with each other. Your driver has to create this device file.

- ### There is a special program in user level called ```Udev```, which actually populates this ```/dev``` directory with various a device files. Device files are managed as part of ```VFS(Virtual File system) subsystem``` of the kernel. ```Udev``` is the device manager for the Linux kernel. It dynamically creates or removes device node files at boot time in the /dev directory for all types of devices. **Udev** is part of **systemd** as you can see by view

> ### When the user space app wants to talk to the hardware, it uses system calls such as open, write, read etc.

- ### And when the user that application uses read and write system calls, those system calls must connect to the read and write implementations or methods of your driver.

![](./Pics/introduction_04.png)

- ### We have to understand how to establish such connections from userspace to the device drivers. And the drivers read and write functions or methods will then forward data to the hardware or it will read data from the hardware. The read method of the driver will read from the hardware and it should submit data back to the user, and the write method of the driver should accept data from the user space, it should write the data to the hardware. 

> ### If you're wondering how these a user space system calls will get connected to the driver system call implementation methods, this is taken care by the VFS (that is virtual file system) of the kernel. That means, our device driver has to get registered with the VFS by using virtual files systems kernel APIs. 


![](./Pics/3.device_driver_04.png)

> ### When the user space application wants to talk to the hardware. It uses a system calls, such as open, read, write. When the user space application uses open system call, that open system call should connect to the open system call implemantation of your driver. And write and read also... If you are wondering how these a user space system calls will get connected to the driver system call implemantation method, this is taken care by the ```VFS(virtual file system)``` of the kernel. That means our device driver has to get registered with the ```VFS``` by using ```virtual files system kernel APIs```.

#
## Device number

- ### Question is that, when you lets say, open system call on this device, how does the kernel connect the open system call to intented driver's to open method?

![](./Pics/3.device_driver_05.png)

- ### TO ESTABLISH THE CONNECTION THE KERNEL USES ```DEVICE NUMBER```. Lets assing a number to this driver, lets say ```4```. Also this device file let's say ```4:0```. Here 4 denotes the number of the driver which should be used to connect this device file access to the drivers methods. And 0 here is a device instance. There could be multiple device files. All are handled by the same driver. For example, there could be 4 RTC devices. All are handled by a single RTC driver. In that case, there could be 4 device files. Like dev/rtc0, rtc1, or 1, or 3, like that. In this case, the device numbers could be 4:0, 4:1, 4:2, or 4:3.

![](./Pics/3.device_driver_06.png)

- ### When user level program uses an open system call on this device file.The system call will first handled by the ```virtual file system```, that is ```VFS``` in the ```kernel space```. So, the ```VFS``` get's the device number and compares it with it's driver registration list. That means, this driver has to get registered with the ```VFS``` using the ```device number```. That what we call as ```character device add```, known as ```CDEV_ADD```.

> ### So, the VFS compares the device number of the device file with the drivers list and picks the correct driver and connects the user requests to the file operation methods of the selected driver.

### STEPS:
- ### Create device number
```C
//Creation
alloc_chrdev_region();
//Deletion
unregister_chrdev_region();
```
- ### Create device files
```C
//Creation
class_create();
device_create();
//Deletion
class_destroy();
device_destroy();
```
- ### Make a char device registration with the ```VFS(CDEV_ADD)```.
```C
//Creation
cdev_init();
cdev_add();
//Deletion
cdev_del();
```
- ### Implement the driver's file operation methods for open, read, write, llseek etc...


![](./Pics/3.device_driver_07.png)

#

## Device number representation

![](./Pics/3.device_driver_08.png)

- ### The device number is a combination of major and minor numbers

- ### In Linux kernel, dev_t (typedef of u32) type is used to represent the device

- ### Out of 32 bits, 12 bits to store major number and remaining 20 bits to store minor number

- ### You can use the below macros to extract major and minor parts of dev_t type variable:
```C
dev_t device_number
int minor_no = device_number
int major_no = device_number
```
- ### You can find these macros in ```linux/kdev_t.h```.

- ### If you have, major and minor numbers , use the below macro to turn them into ```dev_t``` type device number
```MKDEV(int major, int minor);```

#
## CDEV

```C
void cdev_init(struct cdev *cdev, const struct file_operations *fops);
```

- ### ```cdev_init``` is used to initialize a ```cdev``` structure. You can think ```file_operations``` as ```system call handlers```. Since we are handling only one device, we should create a one variable of the ```struct cdev```. 

```C
struct file_operations eeprom_fops;
struct cdev eeprom_cdev;
cdev_init(&eeprom_fops, &eeprom_cdev);
```

> ### ```cdev_init``` is a kernel API, which is implemented in ```char_dev.c```. ```cdev_init``` just initializes the ```ops``` field with the pointer what you pass the function.

```C
/**
 * cdev_init() - initialize a cdev structure
 * @cdev: the structure to initialize
 * @fops: the file_operations for this device
 *
 * Initializes @cdev, remembering @fops, making it ready to add to the
 * system with cdev_add().
 */
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
{
	memset(cdev, 0, sizeof *cdev);
	INIT_LIST_HEAD(&cdev->list);
	kobject_init(&cdev->kobj, &ktype_cdev_default);
	cdev->ops = fops;
}
```

![](./Pics/3.device_driver_09.png)

- ### ```THIS_MODULE``` is a macro which resolves in to 'pointer to a struct module variable called ```__this_module```. That module represents our current module'.

- ### You can find this macro in ```linux/export.h```.

```C
#ifdef MODULE
extern struct module __this_module;
#define THIS_MODULE (&__this_module)
#else
#define THIS_MODULE ((struct module *)0)
#endif
```

![](./Pics/3.device_driver_10.png)

![](./Pics/3.device_driver_11.png)


```C
void cdev_add(struct cdev *p, dev_t dev, unsigned count);
```

- ### ```cdev_add``` is used to register our ```cdev``` structure with ```kernel VFS(virtual file system).```

#

- ### Lets say driver has created a device file ```/dev/pcd```. Lets say user app uses the open system call to open that device file. System call is transferred to the kernel. That happens in the ```VFS```. From user level control is passed to the ```kernel VFS subsystem```. From the ```VFS subsystem``` control is passed to the appropriate drivers open method. 

![](./Pics/3.device_driver_12.png)


## Inode object

- ### Unix makes a clear distinction between the contents of a file and the information about a file.
- ### An inode object is a VFS data structure```(struct inode)``` that holds general information a file.
- ### Whereas VFS ```file``` data structure ```(struct file)``` tracks interaction on an opened file by the user process.
- ### Inode contains all the information needed by the filesystem to handle a file.
- ### Each file has its own inode object, which the filesystem uses to identify the file.
- ### Each inode object is associated with an inode number, which uniquely identifies the file within the filesystem.
- ### The inode object is created and stored in memory as and when a new file(regular or device) gets created.

#

## File object
- ### Whenever a file is opened a file object is created in the kernel space. There will be one file object for every opened regular or device file.
- ### It stores information about the interaction between an open file and a process.
- ### This information exists only in the kernel memory during the period when a process has the open file. The contents of file object is NOT written back to disks unlike inode.


#
## Inode object initialization

- ### Lets say, a device file is created, either manually or by using ```udev```.
- ### Whenever device file is created(```udev``` or ```mknod```) ```init_special_inode()``` gets called by ```VFS```. You can see that ```VFS``` passes the device number of the newly created device file. Whenever a device file is created ```inode``` object will be created. 

![](./Pics/3.device_driver_13.png)

###  Dummy default file-operations:
```C
/*
 * Dummy default file-operations: the only thing this does
 * is contain the open that then fills in the correct operations
 * depending on the special file...
 */
const struct file_operations def_chr_fops = {
	.open = chrdev_open,
	.llseek = noop_llseek,
};
```

- ### Inode object file operation field is initialized with dummy default file operation methods. Inode object is there in the memory now. Whenever the user level program executes open system call on a device file, These are the kernel level functions get involved in processing the open system call. 

![](./Pics/3.device_driver_14.png)

- ### ```do_flip_open```: This is the place ```file``` object allocation. Because for every open, a file object will be created in the kernel space. 
- ### ```do_dentry_open```: The default dummy file operations will be called.```(chrdev_open)```. 
- ### ```do_chrdev_open```: From here, you driver's open method will be called.


```C
static int do_dentry_open(struct file *f,
			  struct inode *inode,
			  int (*open)(struct inode *, struct file *)) {
    ...
    // Copying 'inode's ' fops into 'file' object's fops.
	f->f_op = fops_get(inode->i_fop);
	if (WARN_ON(!f->f_op)) {
		error = -ENODEV;
		goto cleanup_all;
	}

	error = security_file_open(f);
	if (error)
		goto cleanup_all;

	error = break_lease(locks_inode(f), f->f_flags);
	if (error)
		goto cleanup_all;

	/* normally all 3 are set; ->open() can clear them if needed */
	f->f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;
	if (!open)
		open = f->f_op->open;
	if (open) {
		error = open(inode, f);
		if (error)
			goto cleanup_all;
	}
    ...
}
```
#

```C
/*
 * Called every time a character special file is opened
 */
static int chrdev_open(struct inode *inode, struct file *filp)
{
	const struct file_operations *fops;
	struct cdev *p;
	struct cdev *new = NULL;
	int ret = 0;

	spin_lock(&cdev_lock);
	p = inode->i_cdev;
	if (!p) {
		struct kobject *kobj;
		int idx;
		spin_unlock(&cdev_lock);
		kobj = kobj_lookup(cdev_map, inode->i_rdev, &idx);
		if (!kobj)
			return -ENXIO;
		new = container_of(kobj, struct cdev, kobj);
		spin_lock(&cdev_lock);
		/* Check i_cdev again in case somebody beat us to it while
		   we dropped the lock. */
		p = inode->i_cdev;
		if (!p) {
			inode->i_cdev = p = new;
			list_add(&inode->i_devices, &p->list);
			new = NULL;
		} else if (!cdev_get(p))
			ret = -ENXIO;
	} else if (!cdev_get(p))
		ret = -ENXIO;
	spin_unlock(&cdev_lock);
	cdev_put(new);
	if (ret)
		return ret;

	ret = -ENXIO;
	fops = fops_get(p->ops);
	if (!fops)
		goto out_cdev_put;

	replace_fops(filp, fops);
	if (filp->f_op->open) {
		ret = filp->f_op->open(inode, filp);
		if (ret)
			goto out_cdev_put;
	}

	return 0;

 out_cdev_put:
	cdev_put(p);
	return ret;
}
```

- ### ```kobj_lookup(cdev_map, inode->i_rdev, &idx);```: Looking up for cdev you added with ```cdev_add()```. That lookup works by using device number. Thats why you passed the device number while using cdev_add function. That function actually doesnt extract the cdev object directly, so instead it actually extracts kernel object kobj. By using kobj, it extracts the cdev object. 

- ### ```new = container_of(kobj, struct cdev, kobj);```: The container_of macro gives you a pointer to parent object. ```cdev``` is the parent of ```kobj``` actually. By using the child object, the ```container_of``` extracts pointer of parent```(strcuct cdev *new)```. After that it is assigned to the ```i_cdev field``` of ```inode object```. That means this ```cdev *new``` object is nothing but what you added using ```cdev_add()```.

- ### ```fops = fops_get(p->ops);```:  After that ```fops``` get's initialized by using ```cdev```. This is nothing but your drivers file operation pointer. This is initialized by ```cdev_init()```.

- ### ```replace_fops(flip, fops);```: The file pointer had the dummy default file operation.  This is now replaced by actual file operations of your driver by the help of below function.

- ### ```filp->f_op->open(inode, filp);```: Now you are calling the open function of your driver.




